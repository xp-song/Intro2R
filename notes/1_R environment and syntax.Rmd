---
title: "R Environment and Syntax"
subtitle: "[Intro2R](https://github.com/xp-song/Intro2R) crash course: Session 1 of 2"
author: "author: xpsong"
date: "updated: `r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: paper
---

```{r load_packages, echo = FALSE, message = FALSE, warning = FALSE}
#commands are separated by ; or a new line
library(dplyr); library(tidyr) #data manipulation
library(ggplot2) #data visualisation 
library(knitr) #to knit HMTL
```

---

# Objects in R

## Variables
- Used to store data
- Naming should be consistent/clear
  - Case sensitive, no numbers/symbols/whitespace
  - E.g. treeHeight_m, species_count
- **Data types:** Numeric, integer, character, logical (T/F) or complex
```{r variables, eval = FALSE}
#numeric data
x <- 4
x <- (4+5)/2

#character data
x <- "hello"
```

## Data Structures
### Vectors 
- Sequential collection of data of the _same_ type
- Coercion occurs if different types are mixed
- Asking and coercion can be done manually to change the vector (data) type
- Note that the `c()` function combines (concatenates) its arguments to form a vector
```{r eval = FALSE}
#numeric vectors
x <- c(1,3,5,6)
x <- 1:5
x <- seq(1,5,1)
x <- vector("numeric", length=10)
num_vec <- c(TRUE, 2) #in R, TRUE=1, FALSE=0
is.numeric(num_vec) 

#character vectors
x <- c("hello", "a", "b", "c")
x <- c(1.7, "a")
char_vec <- c("a", TRUE) #'TRUE' turned from logical to character
is.character(char_vec) 

x <- as.character(num_vec) #coercion from numeric to character
x
```
### Lists
- Consist of different elements (i.e. variables/vectors) that can be of _different types_
- Elements in a list are indexed with [[]], individual items are in []
- Functions only be applied to vectors, not lists!
```{r eval= FALSE}
mylist <- list(num_vec, char_vec, 1.783, 5L, "hello") #add L suffix if you explicitly want integers
mylist
is.list(mylist) #asking
```

### Factors

- Used to represent data with limited, discrete categories (i.e. categorical, ordinal, or even binary)
- Can be coded as character or numeric
- Some examples:
  - Tom, Dick, Harry
  - Blue, Black, Brown (eye color)
  - High, Medium, Low (3, 2, 1)
  - Strongly disagree, disagree, neutral, agree, strongly agree (-2:2)
  - Male, Female (1, 2)

```{r, eval = FALSE}
x <- factor(c("SA", "D", "A", "A", "SA", "Neutral", "SD"))
x

#define order (default is alphabetical)
x <- factor(c("SA", "D", "A", "A", "SA", "Neutral", "SD"), levels = c("SD", "D", "Neutral", "A", "SA"))
x

unclass(x) #show as numbers, with "levels" attribute showing actual text
```

### Matrices
- Data in rectangular format (2D array with rows & columns)
- Data must be of the _same_ type!
- More memory efficient than dataframes
```{r eval = FALSE}
m <- matrix(1:12, nrow = 4)
m #data goes in by columns in default mode

dim(m) #dimensions: no. of rows & cols 
dimnames(m)
dimnames(m) <- list(c("Tom", "Dick", "Harry", "Me"), c("Blue", "White", "Red")) #add names to row/cols

#size comparisons
object.size(m) # 264 bytes
d <- as.data.frame(m) #convert to dataframe
object.size(d) # 1032 bytes
```

### Dataframes
- Data in rectangular format (2D array with rows & columns)
- Columns can contain _different_ types of data variables (i.e. numeric, character, etc.)
- Each column are vectors/lists of similar length
- Import tabular data as dataframes using `read.table()` family of functions (i.e. `read.csv()`, `read.delim()`)
```{r eval = FALSE}
#use data.frame() to manually create df

ozone <- read.csv("../data/ozone_data.csv") #default: headers in first row (header = T)
is.data.frame(ozone) #check attribute
head(ozone) #view first few rows only

dim(ozone) #dimensions: no. of rows & cols 
dimnames(ozone) #row & col names
names(ozone) #col names, also can use 'colnames(ozone)'
rownames(ozone)

#extract columns with '$'
ozone$rad
ozone$temp
```

## Functions
- Many in-built functions available in packages
- Functions break our code into simpler parts/modules, which helps improve readability
- You can create your own (user-defined) functions, and edit existing ones
- Inputs to a function include R objects and arguments
  - Look up details with `?functionname` (e.g. `?read.csv`)

### Useful functions in base R
__Basic calculation__  

- `log(x)` Log base e of x (natural)  
- `log10(x)` Log base 10 of x
- `log(x,n)` Log base n of x  
- `exp()` Exponential  
- `sqrt()` Square root  
- `sin()`; `cos()`; `tan()`  
- `factorial()`

__Create vectors__  

- `seq(a,b,c)` A vector with elements a:b, with step magnitudes of c (e.g. Days in a year is  `seq(1,365,1)`)  
- `rep(a,b)` A vector with a repeated b times  
  
__Rounding of numeric vectors__  

- `round(x, digits=0)` 0 decimal places for x  
- `signif(x, digits=2)` x rounded to 2 sig. fig.  
- `floor(x)` Largest _integer_ greater than corresponding elements of x (round down)  
- `ceiling(x)` Smallest _integer_ greater than corresponding elements of x (round up)  
- `abs(x)` absolute value
  
__Summary statistics of vectors/tabular data__  

- `mean(x)`
- `median(x)`
- `var(x)` Variance
- `max(x)` Max element
- `min(x)` Min element
- `range(x)` Min & max elements
- `quantile(x)` Returns vector with the quantiles of x
- `nrow()` Number of rows in tabular data
- `ncol()` Number of columns in tabular data
- `length(x)` Number of elements in x (same result as `ncol()` of dataframe)

__Calculation for vectors/matrices__

- `sum(x)` sums elements
- `prod(x)` product of the elements
- `colMeans(x)` 
- `rowMeans(x)`
- `colSums(x)`
- `rowSums(x)`

__Manipulation of vectors/matrices__

- `rank(x)` Vector of the ranks of the values in x (increasing order)
- `sort(x)` Produce another vector with elements in increasing order
- `sample(x, n, replace=T)` Sample a vector n times with replacement
Adding rows/Creating matrices by joining vectors (e.g. adding the vectorA <- c(1,1,1))
- `cbind(x, y)` Bind x & y as columns to form new matrix
- `rbind(x, y)` Bind x & y as rows to form new matrix

__Plotting functions__
```{r}
x <- seq(1,10)
y <- x*10
plot(x,y)
```

### User-defined functions
- Writing functions are incredibly powerful
- You define your own inputs and outputs
- General structure: `functionname <- function(argumentlist){calculations}`
- E.g. Calculate GPA from `grades.csv` using the following formula:

$$
\frac{ sum(Module\ grade\ point * Module\ credits)}{ sum(All\ module\ credits)}
$$

```{r}
grades <- read.csv("../data/grades.csv")
grades

#calculate GPA manually
sum(grades$grade_point * grades$credits) / sum(grades$credits) #element-wise multiplication of vectors

#create function instead
scorer <- function(gradepts, creds){ #inputs are vector objects
  sum(gradepts*creds) / sum(creds)
  }

#use function
scorer(grades$grade_point, grades$credits)
```

<br>

__Loop functions__  

- 'Loop' functions iterate over data to produce output
- Repeats a task/calculation (repeats usually denoted as "i")  
- Various types of loops:
  - `for` Execute a fixed number of times 
  - `if` or `ifelse` Execute on specific conditions
  - `while` Execute while a condition is true (be careful of infinite loops)
  - `repeat` Execute an infinite loop
- Actions within a loop:
  - `break` Break execution
  - `next` Skip an iteration 
  - `return` Exit a function
- Loops can be nested! (i.e. loop within a loop)  
- Perform [subsetting](#subset) to extract/write calculations within loops
  - E.g. `x[i]` refers to the `i`th element in vector `x`

<br>

_Example of FOR loop:_  
```{r}
grades <- read.csv("../data/grades.csv")
grades$weightage <- 0 #add new col for weightage of each module

for(i in 1:nrow(grades)){ #iterate across each row (7 times)
  grades$weightage[i] <- grades$credits[i] / sum(grades$credits) #write
}

#note that you an also calculate directly without a loop (element-wise calculation of vectors)
#grades$weightage_manual <- grades$credits / sum(grades$credits)

grades
```

<br>

_Example of IF loop:_
```{r}
grades$pass <- 0 

for(i in 1:nrow(grades)){ #iterate across each row (7 times)
  
  if(grades$grade_point[i] >= 2){ #loop within loop
    grades$pass[i] <- "yes"
    } else {
      grades$pass[i] <- "no"
    }
}

grades
```

<br>

_Example of a loop function:_
```{r}
passchecker <- function(gradepts){ #vector input, not dataframe!
  
  results <- rep(0,length(gradepts)) #create empty results vector
  
  for(i in 1:length(gradepts)){ #iterate across length of 'gradepts'
    
    if(gradepts[i] >= 2){ 
      results[i] <- "yes"
      } else {
        results[i] <- "no"
      }
  } 
  results #remember to specify output
} 

grades$pass <- passchecker(grades$grade_point) #append as new column
```

<br>

### Loop functions in base R
- `lapply(x, FUN)`: Apply a function on each element of `x`
  - Returns a _list_ (always)
- `sapply(x, FUN)` Similar to `lapply` but tries to simplify results
  - Returns a _vector_ if result is a list where every element is length = 1
  - Returns a _matrix_ if result is a list where every element is of the same length (>1)
  - In all other scenarios, a _list_ is returned
- `apply(x, MARGIN, FUN)` Apply a function to a tabular data by rows or columns (2D dataset)
  - MARGIN argument: 1 indicates rows, 2 indicates columns, c(1,2) indicates rows & columns
  - E.g. Add a "mean" column: `cbind(matrixname, apply(matrixname, 2, mean))`
- `tapply(x, index, FUN)` Apply a function over subsets of a vector
- `mapply()` Multivariate version of `lapply`

<br>

_Example of loop function `lapply`:_
```{r}
#create a list of different types of R objects
a1 <- c("A","B") #char vector
a2 <- c(1,1,2,3,4,4) #numeric vector
a3 <- matrix(1, ncol=3, nrow=3) #matrix
mylist <- list(a1, a2, a3)

lapply(mylist, length) #apply length() function to list
```

<br>

---

# Operators in R
## Arithmetic  

- `+` `-` `*` `/`  
- `^` or `**` Exponentiate  
- `%%` Modulus (e.g. `5%%2` = 1)  
- `%/%` Integer division (e.g. `23%/%5` = 4)  
  
## Logical

- `<` `<=` `>` `>=`
- `==` Exactly equal (e.g. `1e3 == 1*10^3`; `1e-3 == 1*10^-3`)
- `!=` Not equal
- `!x` Not x
- `x|y` x OR y  
- `x&y` x AND y  

## Other  

- `1:10` creates a sequence:
```{r echo = FALSE}
1:10
```
- `$` Extract elements by name from a named list (colnames for tabular data)
```{r}
x <- list(a=1, b=2, c=3)
x$b
```





## Subsetting {#subset}

- Use square brackets `[ ]`
- If dataset has 2 dimensions (i.e. tabular format), always specify row then column number
- Examples:
  - `x[5]` 5th element in vector `x`
  - `df[3,5]` Element in 3rd row & 5th col of dataframe `df`
  - `df[c(3,5),]` Row 3 & 5, all cols of dataframe `df`
  - `df[3:5,]` Row 3,4 & 5, all cols of dataframe `df`
  - `df[-2,]` Everything except row 2 of dataframe `df`
  - `df[df$gender=='F' & df$age > 65, ]` Subset in combination with other operators
