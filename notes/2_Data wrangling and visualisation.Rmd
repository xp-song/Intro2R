---
title: "Data Wrangling and Visualisation"
subtitle: "[Intro2R](https://github.com/xp-song/Intro2R) crash course: Session 2 of 2"
author: "author: xpsong"
date: "updated: `r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: false
    theme: paper
    code_folding: hide
---

---

In this lesson, we will be analysing the [Kaggle Machine Learning and Data Science Survey 2018](https://www.kaggle.com/kaggle/kaggle-survey-2018) dataset. The industry-wide survey presents the state of data science and machine learning. It was published in as raw a format as possible while ensuring the anonymity of respondents.  

The data comes in three different files:

1. **Multiple choice responses**, which we will later assign to variable `multi`.  

2. **Free-form responses** to open-ended questions, which we will later assign to variable `free`.
  - To protect the privacy of respondents, the rows have been randomized such that the responses do not necessarily come from the same survey-taker as those in the multiple choice responses.

3. **Survey schema** shows an overview of responses.  

<br>

**In this lesson, we will only be using the file containing the multiple choice responses.**

_**Credit:** Our survey analysis includes some code snippets adapted from R Notebooks created by the Kaggle users [Heads or Tails](https://www.kaggle.com/headsortails/what-we-do-in-the-kernels-a-kaggle-survey-story) and [Jose Berengueres](https://www.kaggle.com/harriken/storytelling-the-2018-kaggle-survey)._

---

# Preparation {.tabset .tabset-fade .tabset-pills}

## Load packages

- We delve deeper into the [tidyverse](https://www.tidyverse.org) in this lesson, which will require the installation of numerous other packages for data manipulation. 

- We also will use some packages that provide functions for specific analyses and visualisations (e.g. dealing with geospatial data, interactive visualisations, etc.)  

```{r load_packages, message = FALSE, warning = FALSE}
#general data manipulation
library(dplyr) # data manipulation
library(readr) # input/output
library(data.table) # data manipulation
library(tibble) # data wrangling
library(tidyr) # data wrangling
library(stringr) # string manipulation
library(forcats) # factor manipulation

#specific data manipulation
library(purrr) # string manipulation

#general visualisations
library(ggplot2) # visualisation 

#specific visualisation
library(highcharter) # visualisation
library(countrycode) # visualisation


#to knit HMTL document
library(knitr) 
library(kableExtra) 
```

---  

## Load data

Rather than importing our tabular data as _dataframes_, we will import them as _tibbles_. Tibbles are a modern take on dataframes; they keep the features that have stood the test of time, and drop the features that used to be convenient but are now frustrating. More info about tibbles are available [here](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html). 

```{r}
multi <- as_tibble(fread('../data/kaggle-survey-2018/multipleChoiceResponses.csv', skip = 1))

#The function 'fread' in the library(data.table) speeds up reading of data into R
#We skip the first line of the .csv file. The second line contains the actual question headers that become the temporary column names for our data.
```

---  

## Examine data

- Use `colnames()` to examine column names. 
  - They are super-long sentences with white spaces, so we need to wrap the entire colname with backticks (e.g. `` multi$`Duration (in seconds)` ``)
  - This is not very feasible/readable code
  - We'll abbreviate the colnames later on as we analyse each topic in the survey.

- Use `str()` to examine the data classes/structure.

<br>

---  

## Convert data type

The `as_tibble()` function imports text as _character_ format by default. We want to change the multiple choice answers to _factors_ using `mutate_if()`.

- Use the pipe operator `%>%` from `library(dplyr)` to manipulate data in stages 
  - It is a key operater often used in the `tidyverse`.
  - Rather than using nested brackets, the 'pipeline' is highly readable and follows a logical sequence.
```{r}
multi <- multi %>%
  mutate_if(is_character, as_factor)

#functions 'is_character' and 'as_factor' are from the library(purrr) and library(forcats), respectively
```

---  

# Survey analysis {.tabset .tabset-fade .tabset-pills}

Number of respondents: __*`r nrow(multi)`*__  


## Duration

Let's first abbreviate the colname `` `Duration (in seconds)` ``  to `duration` using `rename()`, and change the units from seconds to minutes using `mutate()`.
```{r}
multi <- multi %>%
  rename(duration = `Duration (in seconds)`) %>% #rename column
  mutate(duration = duration/60) #change to minutes (use new colname)
```


Next, we plot a histogram using the function `ggplot()` from `library(ggplot2)`, a very popular package used for data visualisation (see [cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf)).  

Three basic steps (linked with the `+` sign):  
1. Provide _data_  
2. Assign your data _variables_ to _aesthetics_  
3. Assign the graphical _primitives_  
```{r fig.height=3.5, fig.cap="_Note: The dashed line denotes the median survey duration. The x-axis has been transformed to a logarithmic scale._"}
multi %>% #provide data
  ggplot(aes(duration)) + #assign variable 'duration' to aes()
  
  geom_histogram(bins = 50, fill = "grey") +
  geom_vline(xintercept = median(multi$duration), linetype = 2) + #add line for median duration
  
  #customisation
  scale_x_log10(breaks = c(2, 5, 10, 20, 60, 720, 1440)) + #log() x-axis to address extreme values
  labs(x = "Duration (mins)", y = "Number of respondents") + #change axis labels
  ggtitle("Most respondents took 15-20 min to complete survey") #add figure title
```

- Some respondents finished the survey in < 2 mins! They may have rushed it or left it incomplete.
- Some respondents probably left the browser tab open for a loong time.

---  

## Spatial distribution

Here, we are interested in the column `` `In which country do you currently reside?` ``. We want a summary table with the count of respondents per country.

```{r}
multi <- multi %>%
  rename(country = `In which country do you currently reside?`) #rename col first

ctry_n <- multi %>%
  count(country) %>%
  filter(!(country %in% c("Other", "I do not wish to disclose my location"))) %>%
  mutate(iso3 = countrycode(country, origin = "country.name", destination = "iso3c"))
```

- Abbreviate the colname to `country`
- `count()` the number of of observations per `country`
- `filter()` to exclude (`!`) invalid country names (rows) specified `%in%` the vector
- `mutate()` table to add a new column `iso3`, where factor names in `country` are mapped to the country code using `countrycode()`
- We create a new variable `ctry_n`

```{r echo = FALSE}
kable(ctry_n, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = T, position = "center") %>%
    scroll_box(height = "200px")
```

<br>

Before we proceed, let's run a few checks. Are there any duplicated country codes?

```{r eval = FALSE}
duplicated(ctry_n$iso3) #yes!
length(unique(ctry_n$iso3)) == length(ctry_n$iso3) #length of unique values is not equal

#look for the duplicated row
which(duplicated(ctry_n$iso3)) #row 56
ctry_n[duplicated(ctry_n$iso3),] #print row

#print ALL rows using fromLast=TRUE argument
ctry_n[duplicated(ctry_n$iso3) | duplicated(ctry_n$iso3, fromLast=TRUE),]
```

```{r eval = TRUE, echo = FALSE}
ctry_n[duplicated(ctry_n$iso3) | duplicated(ctry_n$iso3, fromLast=TRUE),]
```

Seems like there were two options for South Korea. Let's combine them into 1 row and add up the number of respondents `n`.

```{r}
ctry_n <- ctry_n %>%
  group_by(iso3) %>%
  summarise(country = first(country), #get the first value for country name
            n = sum(n)) #sum up duplicates

#ctry_n[!duplicated(ctry_n$iso3),] #if you want to remove duplicated rows
```


<br>

We can now plot our summary table `ctry_n` as an interactive map using the package [highcharter](http://jkunst.com/highcharter). The map data comes from https://code.highcharts.com/mapdata/custom/world.js. More info [here](https://cran.rstudio.com/web/packages/highcharter/highcharter.pdf). 

```{r fig.height=6}
highchart() %>%
  hc_add_series_map(worldgeojson, #map data to add
                    ctry_n, #our data
                    value = 'n', #colname of interest in ctry_n
                    joinBy = 'iso3') %>% #both datasets have this colname (country code)
  
  #customisation
  hc_title(text = 'Geographical distribution of survey respondents') %>%
  hc_colorAxis(minColor = "#edf8b1", maxColor = "#2c7fb8") %>%
  hc_tooltip(useHTML = TRUE, headerFormat = "", pointFormat = "{point.country}: {point.n} respondents")
```

---

## Country analysis

### Import other data

Let's load some other datasets to analyse alongside our survey data. 


__Total population counts__ from [The World Bank](https://data.worldbank.org/indicator/SP.POP.TOTL), which we assign to variable `pops`:  
```{r warning = FALSE}
pops <- as_tibble(fread('../data/POP_TOTAL_DS2_en_v2.csv', skip = 4, header = TRUE))

pops <- pops %>% 
  rename(country = "Country Name", population = "2018") %>% 
  select(country, population) %>% #we are only interested in these 2 columns 
  mutate(iso3 = countrycode(country, origin = "country.name", destination = "iso3c"))
```

```{r echo = FALSE}
kable(pops, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = T, position = "center") %>%
    scroll_box(height = "200px")
```

Some country names could not be matched to a country code. Let's see which values in `iso3` are  `NA` values and remove them.

```{r eval = FALSE}
which(is.na(pops$iso3)) #index of NA values
pops[is.na(pops$iso3),] #rows with NA values for iso3
```

```{r echo = FALSE}
pops[is.na(pops$iso3),] #rows with NA values for iso3
```

```{r eval = FALSE}
pops <- pops[!is.na(pops$iso3),]

#alternatives:
pops <- pops[complete.cases(pops),] #only include rows that are complete!
na.omit(pops)
```

```{r echo = FALSE}
pops <- pops[!is.na(pops$iso3),]

```


<br>

__Global Innovation Index__ from [INSEAD](https://www.kaggle.com/harriken/insead-global-innovation-index/downloads/insead-global-innovation-index.zip/1), which we assign to variable `innov`:
```{r}
innov <- as_tibble(fread('../data/INSEADGlobalinnovationIndex2018.csv', skip = 0))

innov <- innov %>% 
  rename(country = "Economy", index = "Score") %>% 
  select(country, index) %>%
  mutate(iso3 = countrycode(country, origin = "country.name", destination = "iso3c"))
```

```{r echo = FALSE}
kable(innov, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = T, position = "center") %>%
    scroll_box(height = "200px")
```

<br>

### Combine country data

At this point, we have 3 summary tables about countries (the _country_ is a single row/data point):  

1. `ctry_n` Number of survey respondents
2. `pops` Total population
3. `innov` Innovation index

<br>

Let's combine these tables by country code (`iso3` column)  

- The tables may have different countries from each other
- Let's only keep the rows (countries) that are present in all 3 tables, using the function `inner_join()`
- Check out other ways to join tabular data using `?inner_join`
```{r}
ctry_data <- ctry_n %>% 
  inner_join(innov, by = "iso3") %>% 
  inner_join(pops, by = "iso3")
```

```{r echo = FALSE}
kable(ctry_data, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover"), full_width = T, position = "center") %>%
    scroll_box(height = "200px")
```

<br>

- The colname `country` are also common across the 3 tables. These duplicate variables are given a suffix in the new table.
- Joining tables by country code `iso3` gives us a larger dataset than joining by `country`, since naming of the countries are not always similar

### Proportional representation

Let's calculate the number of respondents as a porportion of the total population in each country, and save it in a new colname `respop10k`.

```{r}
ctry_data$respop10k <- ctry_data$n / ctry_data$population * 10000 #per 10k ppl
```

<br>

Now let's visualise this new column `respop10k`. This time, let's plot it in a bar chart instead of in a world map. But before that, we can specify some design (color) customisations in a new column we'll call `label`.  
```{r fig.height = 7.5}
#design customisations: barplot color
ctry_data$label <- c("normal")
ctry_data[ctry_data$iso3=="USA",]$label = c("benchmark")
ctry_data[ctry_data$iso3=="SGP",]$label = c("high")
ctry_data$label <- factor(ctry_data$label, levels = c("normal", "benchmark", "high")) #convert to factor with specified levels
cols <- c("grey50","black","red") #create vector of corresponding colors

#plot 
plot <- ctry_data %>%
  ggplot(aes(x = reorder(country, respop10k), #plot countries in desc order
             y = respop10k,
             fill = label)) + #barplot fill color
  
  geom_hline(yintercept = c(ctry_data$respop10k[ctry_data$iso3=="USA"],
                            mean(ctry_data$respop10k)),
             linetype = "dotted", 
             color = "grey50") +
  geom_col() +
  
  scale_fill_manual(values = cols) + #values from 'cols' vector mapped to 'fill' aesthetic
  
  #customisation
  labs(x = "", y = "Kaggle survey respondents per 10k population") +
  
  coord_flip()  + #switch x & y axis  
  
  theme(legend.position = "none", 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(), 
        axis.line = element_line(colour = "black")) +
    
  annotate("label", x = 7, y = ctry_data$respop10k[ctry_data$iso3=="USA"], label = "USA",size=3, color="black") +
  annotate("label", x = 7, y = mean(ctry_data$respop10k), label = "Overall mean",size=3, color="black")

print(plot)
```

```{r eval = FALSE}

#learn to save plot
```


---  

## Educational sources

```{r}
multi <- multi %>%
  rename(platform = "On which online platform have you spent the most amount of time? - Selected Choice") %>%
  mutate(platform = na_if(platform, ""))
```

, keep in mind that the “On which online platforms” question allowed for multiple answers. In terms of ML/DS training we only consider percentages > 0, since zero dominates almost every distribution (except for self-taught) and we want to focus on the difference between the small and large percentages.

```{r}
platform_lvl <- multi %>%
  filter(!is.na(platform)) %>%
  mutate(platform = as.character(platform)) %>%
  count(platform) %>%
  arrange(n) %>%
  .$platform

foo <- multi %>%
  group_by(platform) %>%
  summarise(most_often = n()) %>%
  mutate(platform = as.character(platform))

bar <- multi %>%
  select(starts_with("On which online platforms have you begun or completed data science courses? (Select all that apply) - Selected Choice")) %>%
  replace(.=="", NA) %>%
  gather(key = "foo", value = "platform") %>%
  mutate(platform = as.character(platform)) %>%
  group_by(platform) %>%
  summarise(occasionally = n())

p1 <- foo %>%
  filter(!is.na(platform)) %>%
  left_join(bar, by = "platform") %>%
  mutate(platform = fct_relevel(platform, platform_lvl)) %>%
  gather(most_often, occasionally, key = "type", value = "n") %>%
  ggplot(aes(platform, n, fill = type)) +
  geom_col(position = "dodge") +
  theme(legend.position = "top") +
  coord_flip() +
  labs(x = "", y = "Responses", fill = "Usage")  +
  ggtitle("Online learning platforms")
```









Write cleaned data without the index column (i.e. write.csv)


# Your turn!

```{r eval = FALSE}
diamonds <- data(diamonds, package = "ggplot2")

#Some analysis
http://statweb.stanford.edu/~jtaylo/courses/stats202/diamonds.html

```



```{r eval = FALSE}



scale(x, center=TRUE, scale=TRUE): centers & scales the data (deducts the mean per column, divides by standard deviation)


CO2[CO2$Type == "Mississippi",]
CO2[CO2$uptake>mean(CO2$uptake) & CO2$conc>200,]

```



# Interactive Graphs using Plotly

- Try example in _.Rmd_ file
```{r warning = FALSE, message = FALSE, eval = FALSE}
library(shiny)
library(plotly)

data(diamonds, package = "ggplot2")
nms <- names(diamonds)

ui <- fluidPage(

    headerPanel("Diamonds Explorer"),
    sidebarPanel(
        sliderInput('sampleSize', 'Sample Size', min = 1, max = nrow(diamonds),
                                value = 1000, step = 500, round = 0),
        selectInput('x', 'X', choices = nms, selected = "carat"),
        selectInput('y', 'Y', choices = nms, selected = "price"),
        selectInput('color', 'Color', choices = nms, selected = "clarity"),

        selectInput('facet_row', 'Facet Row', c(None = '.', nms), selected = "clarity"),
        selectInput('facet_col', 'Facet Column', c(None = '.', nms)),
        sliderInput('plotHeight', 'Height of plot (in pixels)', 
                    min = 100, max = 2000, value = 1000)
    ),
    mainPanel(
      plotlyOutput('trendPlot', height = "900px")
    )
)

server <- function(input, output) {

  #add reactive data information. Dataset = built in diamonds data
  dataset <- reactive({
    diamonds[sample(nrow(diamonds), input$sampleSize),]
  })

  output$trendPlot <- renderPlotly({

    # build graph with ggplot syntax
    p <- ggplot(dataset(), aes_string(x = input$x, y = input$y, color = input$color)) + 
      geom_point()

    # if at least one facet column/row is specified, add it
    facets <- paste(input$facet_row, '~', input$facet_col)
    if (facets != '. ~ .') p <- p + facet_grid(facets)

    ggplotly(p) %>% 
      layout(height = input$plotHeight, autosize=TRUE)

  })

}

shinyApp(ui, server)
```

<br>

---

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>

Copyright (c) 2019 Song, Xiao Ping
